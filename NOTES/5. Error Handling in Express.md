# Express will catch your synchronous errors, to prevent server chrashing

THIS IS WHAT EXPRESS DOES FOR YOU, IF YOU WOULD THROW AN ERROR IN NORMAL NODEJS SERVER, IT WOULD CRACH LIKE ANY OTHER NODEJS APP, NO MATTER YOU HAVE SERVER OR NOT

```ts
app.get("/hello-world", (req, res) => {
  throw new Error("Hello World Error!");
});
```

SEND A RQUEST WITH HTTPIE:

```
http :3001/hello-world
```

OR WITH SOME HTTP CLIENT LIKE THUNDER CLIENT

**YOU WILL GET HTML BACK; WITH STACK TRACE OF THE ERROR THEN WAS THROWN** (**LIKE I SAID THIS IS ONLY POSSIBLE WITH **)
(POSSIBLE ONLY IF YOU HAVE 'NORMAL' FUNCTION (IF YOU WOULD PUT `async/await` SERVER WOULD CRACH AND YOU WOULDN'T GET HTML WITH ERROR STACK TRACE) AND YOU WOULD HAVE TO RESTART YOUR SERVER

SO, IN CASE OF SYNC ERRORS, EXPRESS IS CATCHING YOUR ERROR, AN ERROR THAT YOU DIDN'T CATCH BY YOURSELF AND IT IS SENDING RESPONSE WITH 500 STATUS AND SOME HTML

WE DON'T WANT TO SEND THAT STUFF TO THE USER; WE NEED TO HANDLE EVERYTHING WE CAN

# DEFINING YOUR OWN ERROR HANDLER

THE DIFFERENCE BETWEEN THIS ONE IS THAT ERROR HANDLER HAS 4 ARGUMENTS: `error`, `req`, `res`, `next`

FIRT ARGUMENT IS ERROR THAT WAS THROWN

THIS HANDLER CAN DO THINGS LIKE ANY HANDLER OR A MIDDLEWARE, ONLY DIFFERENCE IS WHERE YOU PUT IT

IT NEEDS TO COME AFTER ALL THE ROUTS IF YOU WANT TO CATCH ERRORS FROM THESE ROUTES

# NOTHING STOPS YOU TO USE ASYNCHRONOUS THINGS INSIDE ERROR HANDLER

I ONLY TOLD YOU THAT YOU CAN'T JUST THROW ERROR INSIDE ASYNC HANDLER AND EXPECT ERROR HANDLER TO CATCH THAT ERROR

**BUT YOU CAN DO ASYNC THINGS INSIDE ERROR HANDLER** (ADDING INSTRUMENTATION, ERROR LOGING, ERROR REPORTING...)

# SO TO CEMENT KNOWLEDGE ABOUT ERROR HANDLER NOT BEING ABLE TO CATCH ERROR FROM ASYNC HANDLER, OR FROM ANY ASYNC ACTION, LETS DEFINE TWO HANDLERS

```ts
// -----------------------------
// IF YOU HIT THIS ROUTE, SERVER WILL CHRACH
app.get("/hello-world", async (req, res) => {
  throw new Error("Hello World Error!");
});
// IF YOU HIT THIS ROUTE, SERVER WILL CHRACH
app.get("/foo-bar", (req, res) => {
  setTimeout(() => {
    throw new Error("Foo Bar!");
  }, 200);
});
```

# ASYNCRONOUS ERRORS YOU MUST HANDLE BY YOURSELD ON A HANDLER LEVEL, BY USING `next` CALLBACK, BECAUSE SAME AS MIDDLEWARES, THE HANDLERS ALSO CAN HAVE A `next` PARAMETER

**YOU CAN LOOK AT NEXT AS A THING THAT WWILL TRANSPORT ERROR FROM HANDLER OR A MIDDLEWARW, TO THE ERROR HANDLER**



